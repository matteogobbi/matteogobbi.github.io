<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Best Practices | Matteo Gobbi]]></title>
  <link href="http://matteogobbi.github.io/blog/categories/best-practices/atom.xml" rel="self"/>
  <link href="http://matteogobbi.github.io/"/>
  <updated>2014-11-11T23:00:34+00:00</updated>
  <id>http://matteogobbi.github.io/</id>
  <author>
    <name><![CDATA[Matteo Gobbi]]></name>
    <email><![CDATA[job@matteogobbi.it]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Interaction Object]]></title>
    <link href="http://matteogobbi.github.io/blog/2014/10/30/interaction-object/"/>
    <updated>2014-10-30T23:16:22+00:00</updated>
    <id>http://matteogobbi.github.io/blog/2014/10/30/interaction-object</id>
    <content type="html"><![CDATA[<p>Many times in your projects, you are in the situation in which you need to store something in some way, in order to use it in the most efficient way possible.
In detail, sometime happen that you need to create a hamburger menu or a list of pretty static items, using a <code>UITableView</code>.</p>

<p>In this article I will go to consider a recurrent situation, showing how to implement and follow the very easy approach to have a set of <strong>Interaction Object</strong>, making our code clean and testable.</p>

<!--more-->


<p><br/></p>

<h2>The problem</h2>

<p>In my last two companies, I have been in the situation to create a hamburger menu using a <code>UITableView</code>, like this:</p>

<p style="text-align:center;"> <img src="/../images/posts/interaction-object/1.jpg" height="300" alt="Hamburger Menu" /></p>

<p>As a pretty static menu, it was not fetched from any datasource, therefore I thought &ldquo;<strong>what is the best method to represent the menu items?</strong>&rdquo;.<br/>
A na√Øve and rude approach would be something like:</p>

<pre><code class="objc">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    switch (indexPath.row) {

        //....get/create a cell etc.

        case 0: 
        {
            cell.title = @"Home";
            break;
        }

        case 1: 
        {
            cell.title = @"Favourites";
            break;
        }

        //...
    }

    //..

    return cell;
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    switch (indexPath.row) {

        case 0: 
        {
            [self goToHome];
            break;
        }

        case 1: 
        {
           [self goToFavourites];
            break;
        }

        //...
    }

    //..
}
</code></pre>

<p>&hellip;&hellip;</p>

<p style="text-align:center;"> <img src="/../images/posts/interaction-object/2.gif" height="300" alt="Shit" /></p>

<p>Yes, it is dirty and not scalable.</p>

<p>What if you want add another cell then? And if you want the new cell be somewhere in the middle? You should change every case&rsquo;s number. What if you want display different cells in according with a condition (i.e. user/admin)?</p>

<p>In short, this is not a good approach at all. So..how?</p>

<p><br/></p>

<h2>The solution</h2>

<p>As a menu, any cell needs 3 basic and foundamental things:</p>

<ul>
<li>An image;</li>
<li>A title;</li>
<li>An action.</li>
</ul>


<p>The idea is to have a component (<strong>MGInteractionObject</strong>, precisely) to store these informations, and having then an array of these components in order to associate them to the cells. Moreover, this approach will give us the opportunity to manage the array, choosing wich items show and wich not in according with certain events or conditions.</p>

<p>Therefore, the header file would looks something like:</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

typedef void(^performBlock)();

typedef NS_ENUM(NSUInteger, MGActionType) {
    MGActionTypeBlock        = 1,
    MGActionTypeSelector
};

@interface MGInteractionObject : NSObject

@property (copy, nonatomic, readonly) NSString *title;
@property (copy, nonatomic, readonly) NSString *imageName;

@property (assign, nonatomic, readonly) MGActionType actionType;
@property (assign, nonatomic, readonly) SEL selector;
@property (copy, nonatomic, readonly) performBlock block;

- (instancetype)initWithTitle:(NSString *)title imageName:(NSString *)imageName selector:(SEL)selector;
- (instancetype)initWithTitle:(NSString *)title imageName:(NSString *)imageName performBlock:(performBlock)block;

@end
</code></pre>

<p>Basically, as I said, we store a <strong>title</strong> for the menu item, an <strong>image</strong> and an <strong>action</strong>, which might be performed by a <strong>block</strong>, or by a <strong>selector</strong>. Finally, we have an <strong>enumeration</strong> in order to present to the developer the different ways to perform the action.<br/>
Of course, here I reported just some basic information to store, but it could be expanded a lot, for example with the following properties:</p>

<pre><code class="objc">@property (copy, nonatomic, readonly) NSString *highlightedTitle;
@property (copy, nonatomic, readonly) NSString *highlightedImageName;
@property (strong, nonatomic, readonly) UIColor *backgroundColor;
@property (strong, nonatomic, readonly) UIColor *highlightedBackgroundColor;
//..etc
</code></pre>

<p>Now that we know the header, it&rsquo;s the time to have a look to the implementation code:</p>

<pre><code class="objc">#import "MGInteractionObject.h"

@implementation MGInteractionObject

#pragma mark - Public init
- (id)init {
    @throw [NSException
        exceptionWithName:NSInternalInconsistencyException
                   reason:@"Must use initWithTitle:imageName:selector: or initWithTitle:imageName:performBlock:"
                 userInfo:nil];
}

- (instancetype)initWithTitle:(NSString *)title imageName:(NSString *)imageName selector:(SEL)selector
{
    return [self initWithTitle:title imageName:imageName selector:selector performBlock:nil];
}

- (instancetype)initWithTitle:(NSString *)title imageName:(NSString *)imageName performBlock:(performBlock)block
{
    return [self initWithTitle:title imageName:imageName selector:nil performBlock:block];
}

#pragma mark - Private init
- (instancetype)initWithTitle:(NSString *)title imageName:(NSString *)imageName selector:(SEL)selector performBlock:(performBlock)block
{
    if(self = [super init]) {
        _title = [title copy];
        _imageName = [imageName copy];
        _selector = selector;
        _block = [block copy];

        _actionType = (selector) ? MGActionTypeSelector : MGActionTypeBlock;
    }
    return self;
}

@end
</code></pre>

<p>Simple and easy.</p>

<p>Now we have the base element. Let&rsquo;s proceed to properly use it.</p>

<p><br/></p>

<h2>How to use it</h2>

<p>What we need to do now, is to create an interaction object for each menu item.<br/>
Supposing to have <strong>4 items</strong>:</p>

<ul>
<li>Home;</li>
<li>Favourites;</li>
<li>Stores;</li>
<li>Admin options.</li>
</ul>


<p>we should simply go to create <strong>4 interaction objects</strong> like these:</p>

<pre><code class="objc">- (void)mg_createMenuInteractionItemsForUser:(MGUser *)user
{

    __weak typeof (self) weakSelf = self;

    MGInteractionObject *objHome = 
        [[MGInteractionObject alloc] initWithTitle:@"Home"
                                         imageName:@"icon_home" 
                                   performSelector:@selector(openHome)];

    MGInteractionObject *objFavourites = 
        [[MGInteractionObject alloc] initWithTitle:@"Favourites"
                                         imageName:@"icon_favourites" 
                                      performBlock:^{
                                                    //Do something    
                                                    }];

    MGInteractionObject *objStores = 
        [[MGInteractionObject alloc] initWithTitle:@"Stores"
                                         imageName:@"icon_stores" 
                                   performSelector:@selector(openStores)];


    //Prepare tableButtons
    NSArray *tableButtons;
    if(user.isAdmin) {

        MGInteractionObject *objAdmin = 
            [[MGInteractionObject alloc] initWithTitle:@"Admin options"
                                             imageName:@"icon_admin" 
                                          performBlock:^{
                                                        //Do something        
                                                        }];

        tableButtons = @[
                        objHome,
                        objFavourites,
                        objStores,
                        objAdmin
                        ];
    } else {
        tableButtons = @[
                        objHome,
                        objFavourites,
                        objStores
                        ];
    }

    return tableButtons;
}
</code></pre>

<p>Having these 4 objects, we return an array of <code>MGInteractionObject</code>, in according with the conditions we want to consider. In this example, it is checked if the user is an admin (<code>user.isAdmin</code>) to decide <strong>if add or not the admin interaction object</strong>, in the array <code>tableButtons</code>.</p>

<p>At this point the last step is just to reload the table getting the tableView&rsquo;s cells:</p>

<pre><code class="objc">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *cellIdentifier = @"InteractionCell";

    MGInteractionCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];

    if(!cell) {
        cell = [[MGInteractionCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier];
    }

    //Get the interaction object
    MGInteractionObject *interactionObject = _tableButtons[indexPath.row];

    //Set the interaction object for this cell to configure it
    cell.interactionObject = interactionObject;

    return cell;
}
</code></pre>

<p>Here it is used a custom cell <code>MGInteractionCell</code> which has the property <code>interactionObject</code>, which throught the <strong>setter</strong> method, configure the cell.<br/>
Obviously, it could be also used a normal <code>UITableViewCell</code> setting the <code>title</code> and the <code>image</code> directly from this method.</p>

<p>Finally, when a user touch a cell, it is called <code>tableView:didSelectRowAtIndexPath:</code>:</p>

<pre><code class="objc">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    //Get the interaction object
    MGInteractionObject *interactionObject = _tableButtons[indexPath.row];

    //Perform the block or the selector
    switch (interactionObject.interactionType) {
        case MGActionTypeBlock:
            interactionObject.block();
            break;
        case MGActionTypeSelector: {
            if ([self respondsToSelector:interactionObject.selector]) {
                [self performSelector:interactionObject.selector withObject:nil];
            }
            break;
        }
    }
}
</code></pre>

<p>where it is checked if <strong>perform the block</strong> or <strong>perform the selector</strong>.</p>

<p>And..</p>

<p>..that&rsquo;s it!</p>

<p style="text-align:center;"> <img src="/../images/posts/interaction-object/3.gif" height="300" alt="Happy" /></p>

<p>Enjoy! ;)</p>
]]></content>
  </entry>
  
</feed>
